---
title: Android自动开关机实现
date: 2016-01-11T14:10:29+08:00
update: 2016-01-01
categories: [Android底层]
tags:
---
Android自动开关机实现

关于android自动关机，网上有很多应用程序和例子。 相对于自动开机来说，自动关机可以在应用层通过设置alarm来实现。而自动开机，网上的介绍就比较少了，因为它需要底层rtc时钟的支持。前段时间根据客户需求实现了自动开关机。在这里分享一下。

1. 简介

我的实现是在设置程序里面增加一个接口，让用户设置自动开关机，这个自动开关机的设置可以参照闹钟的设置。关于自动关机，考虑到关机的时候，用户可能正有一些重要的操作，那么应该给用户一个机会去取消当前的关机。

1）一个BroadcastReceiver, 接收如下信息：

　　a) 自定义的ACTION_REQUEST_POWER_OFF：设置auto power off时，通过AlarmManager设置的一个RTC_WAKEUP时钟。当到设置的关机时间时，之前设置到AlarmManager的这个action会被广播。我们实现的这个BroadcastReceiver接收到这个消息后，就要开始power off流程

　　b) 自定义的ACTION_REQUEST_POWER_ON：设置auto power on时，通过AlarmManager设置的一个RTC_WAKEUP时钟。我们知道power on的应该设置一个rtc的alarm，那么这个RTC_WAKEUP的alarm是做什么的呢？其实当用户设置自动关机的时候，我设置了2个时钟，一个是RTC时钟，用于关机状态下开机；还有一个就是这个RTC_WAKEUP时钟。之所以设置这个时钟，其实是这样的，比如说你设置了周一到周五每天7点半自动开机，而周四早上你7点就打开了手机，这样到7点半的时候，之前设置的时钟就过期了，如果不重新设置的话，周五早上是不会自动开机的。所以这个时候，之前设置的RTC_WAKEUP就接收到了这样的信息，在重新设置下次自动开机的时钟。

　　c) BOOT_COMPLETE和TIMEZONE changed, Time set等时间相关的action：当系统开机完成或时间、时区发生改变时，都需要重新设置alarm。

2）一个处理power off 的Service，当BroadcastReceiver接收到ACTION_REQUEST_POWER_OFF，我们给用户一个机会去取消当前的自动关机。这个Service的作用就是启动一个无背景的页面，给用户提示。同时播放之前用户设置的提示音或振动。

3）一个Activity：显示一个dialog提示用户要自动关机，并用一个计时器倒计时。当用户确认关机，或者计时器到时间的时候，就关机。否则取消当前关机，并重设下次自动关机alarm。


2. 自动关机的实现。自动关机的实现比较简单，这里主要说一下怎么设置alarm，和实现关机：

1） 设置自动关机的alarm：


```

   AlarmManager am = (AlarmManager) context
               .getSystemService(Context.ALARM_SERVICE);

       Intent intent = new Intent(
               "com.android.settings.action.REQUEST_POWER_OFF");

       PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0,
               intent, PendingIntent.FLAG_CANCEL_CURRENT);
       am = (AlarmManager) context
               .getSystemService(Context.ALARM_SERVICE);
       am.set(AlarmManager.RTC_WAKEUP, time, pendingIntent);

```

2）自动关机掉的是./frameworks/base/services/java/com/android/server/ShutdownActivity.java：

       Intent newIntent = new Intent(Intent.ACTION_REQUEST_SHUTDOWN);
       newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
       startActivity(newIntent);

Intent.ACTION_REQUEST_SHUTDOWN是Intent里面一个隐藏的action。



3. 自动开机的实现。一直在做上层应用和framework，对于底层不是很熟悉。正好有同事之前做过关机闹铃，所以把他之前的实现稍加改动就可以了。在系统power off的状态下自动开机，我们需要设置一个rtc时钟，当用户设置自动开机时，由AlarmManagerService将时钟设置下去。这学要底层的支持。这里的实现是定义一个我们自己的rtc alarm type：

1） 首先要在头文件里面定义：

　　a) kernel/include/linux/android_alarm.h
```
#define ANDROID_ALARM_GET_TIME(type)        ALARM_IOW(4, type, struct timespec)
#define ANDROID_ALARM_SET_RTC               _IOW('a', 5, struct timespec)

/* we define ANDROID_RTC_ALARM_SET for auto power off */
#define ANDROID_RTC_ALARM_SET               _IOW('a', 7, int)

#define ANDROID_ALARM_BASE_CMD(cmd)         (cmd & ~(_IOC(0, 0, 0xf0, 0)))

```

　　b) bionic/libc/kernel/common/linux/android_alarm.h

`#define ANDROID_RTC_ALARM_SET _IOW('a', 7, int)`

2) 定义完成之后，还需要实现：在kernel/drivers/rtc/alarm-dev.c文件的alarm_ioctl方法里面，增加一个case，实现设置alarm
```

   case ANDROID_RTC_ALARM_SET:
       {
           unsigned int rtc_alarm_time;
           struct rtc_time rtc_now;
           if (copy_from_user(&rtc_alarm_time, (void __user *)arg,
               sizeof(rtc_alarm_time))) {
               rv = -EFAULT;
               goto err1;
           }
           if (pmic_rtc_get_time(&rtc_now) < 0) {
               rtc_now.sec = 0;
               if (pmic_rtc_start(&rtc_now) < 0) {
                   printk("get and set rtc info failed\n");
                   break;
               }
           }
           pmic_rtc_disable_alarm(PM_RTC_ALARM_1);
           rtc_now.sec += rtc_alarm_time;
           pmic_rtc_enable_alarm(PM_RTC_ALARM_1, &rtc_now);
           break;
       }

```

当然不要忘记增加一个include：

#include <mach/pmic.h>

3）在frameworks/base/services/jni/com_android_server_AlarmManagerService.cpp里面增加一个方法去设置时钟：
```

static void android_server_AlarmManagerService_updateRtcAlarm(JNIEnv* env, jobject obj, jint fd, jint seconds)
{
#if HAVE_ANDROID_OS
   int result = ioctl(fd, ANDROID_RTC_ALARM_SET, &seconds);
   LOGE("set rtc alarm to %d later: %s\n", seconds, strerror(errno));
   if (result < 0)
   {
       LOGE("Unable to set rtc alarm to %d later: %s\n", seconds, strerror(errno));
   }
#endif
}

```

还有就是不要忘记定义一下接口：

{"updateRtcAlarm", "(II)V", (void*)android_server_AlarmManagerService_updateRtcAlarm},

4） 在frameworks/base/services/java/com/android/server/AlarmManagerService.java里面定义native的设置alarm的方法，然后调用就可以实现将自动关机的alarm设置下去了：

定义：private native void updateRtcAlarm(int fd, int seconds);

调用：
```

   public void setRepeating(int type, long triggerAtTime, long interval,
           PendingIntent operation) {
       if (operation == null) {
           Slog.w(TAG, "set/setRepeating ignored because there is no intent");
           return;
       }
       synchronized (mLock) {
           Alarm alarm = new Alarm();
           alarm.type = type;
           alarm.when = triggerAtTime;
           alarm.repeatInterval = interval;
           alarm.operation = operation;

           // Remove this alarm if already scheduled.
           removeLocked(operation);

           if (localLOGV) Slog.v(TAG, "set: " + alarm);

           int index = addAlarmLocked(alarm);
           if (index == 0) {
               setLocked(alarm);
           }

           // Start to setup auto power on alarm
           if ((alarm.type == AlarmManager.ELAPSED_REALTIME_WAKEUP) &&
                               alarm.operation.getTargetPackage().equals("com.android.settings")) {
               updateRtcAlarm(mDescriptor, (int)((alarm.when - System.currentTimeMillis()) / 1000));
           }
           // End to setup auto power on alarm
       }
   }

```

5）在应用层设置自动开机
```

       AlarmManager am = (AlarmManager) context
               .getSystemService(Context.ALARM_SERVICE);
       Intent intent = new Intent(
               "com.android.settings.action.REQUEST_POWER_ON");
       PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0,
               intent, PendingIntent.FLAG_CANCEL_CURRENT);
       am = (AlarmManager) context
               .getSystemService(Context.ALARM_SERVICE);
       am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, time, pendingIntent);

```

4. 总结

1） 自动开机原理比较简单，但是需要底层的支持，所以对于做应用或者framework层的技术人员来说，实现起来稍微比较麻烦。
2） 在设置自动开关机的时候，需要考虑的情况很多，比如是否设置时间/时区的改变，手机当前是开机还是关机状态等。
