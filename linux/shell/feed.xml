<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>时光小栈</title>
    <link>/linux/shell/</link>
    <description>Recent content on 时光小栈</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <managingEditor>rinetd@163.com (rinetd)</managingEditor>
    <webMaster>rinetd@163.com (rinetd)</webMaster>
    <copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 30 Mar 2019 10:12:13 +0800</lastBuildDate>
    
	<atom:link href="/linux/shell/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>shell system exec fork</title>
      <link>/linux/shell/shell-system-exec-fork/</link>
      <pubDate>Sat, 30 Mar 2019 10:12:13 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-system-exec-fork/</guid>
      <description>原文地址 https://www.cnblogs.com/qingergege/p/6601807.html 启动新进程（system 函数） system() 函数可以启动一个新的进程。 int system (const char *string) 这个函数的效果就相当于执行 sh –c string。 一般来说，使用 system</description>
    </item>
    
    <item>
      <title>shell subprocess子进程</title>
      <link>/linux/shell/shell-subprocess%E5%AD%90%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Thu, 24 Jan 2019 10:33:07 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-subprocess%E5%AD%90%E8%BF%9B%E7%A8%8B/</guid>
      <description>子进程执行 通过 . 和 source 命令执行的脚本 会在当前的shell进程中执行,继承当前的环境变量 通过 sh 和 ./run.sh 执行的脚本 会新建shell进程,只有expor</description>
    </item>
    
    <item>
      <title>shell 编程小助手</title>
      <link>/linux/shell/shell-helper/</link>
      <pubDate>Sat, 05 May 2018 13:49:14 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-helper/</guid>
      <description>shell 编程小助手 在众多命令中,一个命令可以帮助你进行shell编程,这个命令就是--- help.参数很多,对新老手都有帮助. 直接在命令行输出he</description>
    </item>
    
    <item>
      <title>shell 获取参数</title>
      <link>/linux/shell/shell-getopts/</link>
      <pubDate>Sat, 05 May 2018 13:49:14 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-getopts/</guid>
      <description>#!/bin/sh host=&amp;quot;localhost&amp;quot; port=3306 # 1. 选项后面的冒号表示该选项需要参数 # 2. 获取参数使用 $OPTARG while getopts &#39;:hp&#39; args do case $args in h) host=$OPTARG ;; p) port=$OPTARG ;; ?) echo $args &#39;not matched&#39; exit 1 ;; :) echo &amp;quot;Option -$OPTARG requires an argument.&amp;quot; &amp;gt;&amp;amp;2 exit 1 ;; *) printf &amp;quot;Usage: %s\n&amp;quot; $0 exit ;;</description>
    </item>
    
    <item>
      <title>Shell Read Config</title>
      <link>/linux/shell/shell-read-config/</link>
      <pubDate>Sat, 05 May 2018 11:41:04 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-read-config/</guid>
      <description>file=&amp;quot;$1&amp;quot; FS_OLD=$IFS IFS=&amp;quot;\n&amp;quot; while read line || [[ -n &amp;quot;$line&amp;quot; ]] do IFS=&amp;quot;,\n&amp;quot; read -a array &amp;lt;&amp;lt;&amp;lt; &amp;quot;$line&amp;quot; echo $((array[0] % array[1])) IFS=&amp;quot;\n&amp;quot; done &amp;lt; &amp;quot;$file&amp;quot; IFS=$IFS_OLD ls download/*.html | while read LINE; do perl parseDocs.pl $LINE 2&amp;gt;/dev/null done IFS=&#39;|&#39; read -a split_input &amp;lt;&amp;lt;&amp;lt; &amp;quot;$1&amp;quot; echo &amp;quot;Enter filename to parse: &amp;quot; read FILE [ -n $FILE ] || FILE=backend.conf # IFS=&amp;quot;$DELIM&amp;quot; while IFS=&#39;, \t&#39; read -r name port ssh_host ssh_port</description>
    </item>
    
    <item>
      <title>Zsh中的别名</title>
      <link>/linux/shell/zsh-alias/</link>
      <pubDate>Thu, 26 Apr 2018 13:31:46 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/zsh-alias/</guid>
      <description>路径别名 zsh 提供了一个很好用的功能，路径别名 这样针对很长的路径，就不用cd + Tab 来回切了 #define: hash -d dir_name=&amp;quot;dir_path&amp;quot; #usage: cd ~dir_name or ~dir_name hash -d myweb=&amp;quot;/data/www/mywebsite&amp;quot; cd ~myweb 或者 ~myweb 或者直接myweb 就相</description>
    </item>
    
    <item>
      <title>Linux Bash-Zsh 快捷键模式 Emacs-Vim</title>
      <link>/linux/shell/linux-zsh/</link>
      <pubDate>Tue, 24 Apr 2018 14:36:45 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/linux-zsh/</guid>
      <description>ZSH开发指南 zsh - Prompt Expansion 13 Prompt Expansion (zsh) 0=${(%):-%N} %N The name of the script If there is none, this is equivalent to the parameter $0 source ${0:A:h}/zsh.d/.zplug.zsh :A 等价于 readlink 读取原文件的地址 :h 字符串截取 目录 zsh compinit: insecure directories, run compaudit for list. Ignore insecure directories and continue [y]</description>
    </item>
    
    <item>
      <title>bash中文手册Handbook</title>
      <link>/linux/shell/handbook/</link>
      <pubDate>Thu, 19 Apr 2018 14:40:33 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/handbook/</guid>
      <description>前言 如果你是一个程序员，时间的价值想必心中有数。持续优化工作流是你最重要的工作之一。 在通往高效和高生产力的路上，我们经常不得不做一些重复的劳</description>
    </item>
    
    <item>
      <title>Makefile 详解</title>
      <link>/linux/shell/makefile/</link>
      <pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/makefile/</guid>
      <description>建立一个入口Makefile执行指定子目录中的Makefile SUBDIRS = src .PHONY: all clean all: @list=&#39;$(SUBDIRS)&#39;; for subdir in $$list; do \ echo &amp;quot;Make in $$subdir&amp;quot;;\ $(MAKE) -C $$subdir;\ done .PHONY: clean clean: @echo Making clean @list=&#39;$(SUBDIRS)&#39;; for subdir in $$list; do \ echo &amp;quot;Clean in $$subdir&amp;quot;;\</description>
    </item>
    
    <item>
      <title>Shell常用招式大全-入门篇</title>
      <link>/linux/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</link>
      <pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</guid>
      <description>采用source 而不是bash 命令 可以将环境变量传递过去 第一招 HelloWorld 第一式：echo echo &amp;quot;Hello World&amp;quot; echo -n &amp;quot;Hello World&amp;quot; # 不带换行 echo -e &#39;\e[0;33;1mHello\e[0m World&#39; # 带颜色的玩法 echo -e &#39;\e[0;33;4mHello\e[0m World&#39; # 带颜</description>
    </item>
    
    <item>
      <title>shell中冒号:的作用</title>
      <link>/linux/shell/shell-%E5%86%92%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-%E5%86%92%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>I. 在shell 中冒号的作用 用作变量条件赋值 {str:=expr} 如果变量str不为空,${str:=expr}就等于str的值，若str为空，就把expr的值赋</description>
    </item>
    
    <item>
      <title>shell中方括号在比较中的使用规则</title>
      <link>/linux/shell/shell-%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>(括号)的作用 Shell中的括号有其特殊的用法, 现总结如下: 符号$后的括号 ${a} 变量a的值, 在不引起歧义的情况下可以省略大括号. $(cmd) 命令替换, 结果</description>
    </item>
    
    <item>
      <title>shell中的map使用</title>
      <link>/linux/shell/shell-array-map/</link>
      <pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-array-map/</guid>
      <description>bash 的版本必须 &amp;gt;= 4.1.2，升级bash： declare -A abc declare: usage: declare [-afFirtx] [-p] [name[=value] ...] shell中map的定义与使用 declare -A 变量名 #切记使用大写的A，不是小写的a [root@www ~]# declare -A</description>
    </item>
    
    <item>
      <title>shell中的字符串截取</title>
      <link>/linux/shell/shell-substr%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96/</link>
      <pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-substr%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96/</guid>
      <description>1、第一种方法: # ${varible##*string} 从左-&amp;gt;右截取最后一个string后的字符串 # ${varible#*string}从左-&amp;gt;右截取第一个str</description>
    </item>
    
    <item>
      <title>shell基础</title>
      <link>/linux/shell/shell%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell%E5%9F%BA%E7%A1%80/</guid>
      <description>sh &amp;quot;文件.sh&amp;quot; , 之后跟文件名,新开子进程执行 sh -c &amp;quot;命令&amp;quot; , 直接把要执行的命令传递给 sh -c &#39;let c=$PATH;echo &amp;quot;c=$c&amp;quot;&#39; &amp;qu</description>
    </item>
    
    <item>
      <title>shell条件判断</title>
      <link>/linux/shell/shell-compare%E6%AF%94%E8%BE%83/</link>
      <pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-compare%E6%AF%94%E8%BE%83/</guid>
      <description>value 数值比较 -eq 等于 if [ &amp;quot;$a&amp;quot; -eq &amp;quot;$b&amp;quot; ] -ne 不等于 if [ &amp;quot;$a&amp;quot; -ne &amp;quot;$b&amp;quot; ] -gt 大于 if [ &amp;quot;$a&amp;quot; -gt &amp;quot;$b&amp;quot; ] -ge 大于等于 if [ &amp;quot;$a&amp;quot; -ge &amp;quot;$b&amp;quot; ] -lt 小于 if [ &amp;quot;$a&amp;quot; -lt &amp;quot;$b&amp;quot; ] -le 小于等于 if [ &amp;quot;$a&amp;quot; -le &amp;quot;$b&amp;quot; ] &amp;lt; 小于（使用</description>
    </item>
    
    <item>
      <title>Makefile常用技巧</title>
      <link>/linux/shell/makefile-variable/</link>
      <pubDate>Sat, 09 Jan 2016 14:01:36 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/makefile-variable/</guid>
      <description>target ... : prerequisites ... command target 也就是一个目标文件，可以是 Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章</description>
    </item>
    
    <item>
      <title>Shell (双引号)与(单引号)的区别</title>
      <link>/linux/shell/shell-%E5%BC%95%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Sat, 09 Jan 2016 14:01:36 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/shell-%E5%BC%95%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>1. &amp;quot;&amp;quot;(双引号) 与&#39;&#39;(单引号) 差在哪？ hard quote：&#39;&#39;(单引号)，凡在 hard quote 中的所有 meta 均被关闭； soft quote：&amp;quo</description>
    </item>
    
    <item>
      <title>Linux命令 bash</title>
      <link>/linux/shell/bash/</link>
      <pubDate>Wed, 06 Jan 2016 16:46:14 +0800</pubDate>
      <author>rinetd@163.com (rinetd)</author>
      <guid>/linux/shell/bash/</guid>
      <description>Linux 技巧: Bash 测试和比较函数 Bash的=~正则表达式匹配 [](http://mywiki.wooledge.org/BashPitfalls/) 快捷键 编辑当前命令 把当前的命令行存放到文本编辑器中 &amp;lt;&amp;lt;&amp;lt; 就是将后面的内容作为前面命令的标准</description>
    </item>
    
  </channel>
</rss>