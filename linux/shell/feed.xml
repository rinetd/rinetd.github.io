<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>时光小栈</title><link>/linux/shell/</link><description>Recent content on 时光小栈</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>rinetd@163.com (rinetd)</managingEditor><webMaster>rinetd@163.com (rinetd)</webMaster><copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright><lastBuildDate>Thu, 30 Apr 2020 10:39:02 +0800</lastBuildDate><atom:link href="/linux/shell/feed.xml" rel="self" type="application/rss+xml"/><item><title>shell readdir</title><link>/linux/shell/shell-readdir/</link><pubDate>Thu, 30 Apr 2020 10:39:02 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-readdir/</guid><description>截取文件扩展名 $ fullfile=/the/path/mylib.1.0.1a.zip $ fullname=&amp;quot;${fullfile##/}&amp;quot; $ dir=&amp;quot;${fullfile%/}&amp;quot; $ extension=&amp;quot;${fullname##.}&amp;quot; $ filename=&amp;quot;${fullname%.}&amp;quot; $ echo $dir , $fullname , $filename , $extension /the/path , mylib.1.0.1a.zip , mylib.1.0.1a , zip #!/bin/bash src=&amp;quot;./Private&amp;quot; #源文件的父目录 dst=&amp;quot;./timeLine3&amp;quot; #目标目录 function read_dir(){ for file in `ls $1`;do #step1 遍历文件 echo &amp;quot;判断</description></item><item><title>shell system exec fork</title><link>/linux/shell/shell-system-exec-fork/</link><pubDate>Sat, 30 Mar 2019 10:12:13 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-system-exec-fork/</guid><description>原文地址 https://www.cnblogs.com/qingergege/p/6601807.html 启动新进程（system 函数） system() 函数可以启动一个新的进程。 int system (const char *string) 这个函数的效果就相当于执行 sh –c string。 一般来说，使用 system</description></item><item><title>shell subprocess子进程</title><link>/linux/shell/shell-subprocess%E5%AD%90%E8%BF%9B%E7%A8%8B/</link><pubDate>Thu, 24 Jan 2019 10:33:07 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-subprocess%E5%AD%90%E8%BF%9B%E7%A8%8B/</guid><description>子进程执行 通过 . 和 source 命令执行的脚本 会在当前的shell进程中执行,继承当前的环境变量 通过 sh 和 ./run.sh 执行的脚本 会新建shell进程,只有expor</description></item><item><title>shell 编程小助手</title><link>/linux/shell/shell-helper/</link><pubDate>Sat, 05 May 2018 13:49:14 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-helper/</guid><description>shell 编程小助手 在众多命令中,一个命令可以帮助你进行shell编程,这个命令就是--- help.参数很多,对新老手都有帮助. 直接在命令行输出he</description></item><item><title>shell 获取参数</title><link>/linux/shell/shell-getopts/</link><pubDate>Sat, 05 May 2018 13:49:14 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-getopts/</guid><description>#!/bin/sh host=&amp;quot;localhost&amp;quot; port=3306 # 1. 选项后面的冒号表示该选项需要参数 # 2. 获取参数使用 $OPTARG while getopts &#39;:hp&#39; args do case $args in h) host=$OPTARG ;; p) port=$OPTARG ;; ?) echo $args &#39;not matched&#39; exit 1 ;; :) echo &amp;quot;Option -$OPTARG requires an argument.&amp;quot; &amp;gt;&amp;amp;2 exit 1 ;; *) printf &amp;quot;Usage: %s\n&amp;quot; $0 exit ;;</description></item><item><title>Shell Read Config</title><link>/linux/shell/shell-read-config/</link><pubDate>Sat, 05 May 2018 11:41:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-read-config/</guid><description>file=&amp;quot;$1&amp;quot; FS_OLD=$IFS IFS=&amp;quot;\n&amp;quot; while read line || [[ -n &amp;quot;$line&amp;quot; ]] do IFS=&amp;quot;,\n&amp;quot; read -a array &amp;lt;&amp;lt;&amp;lt; &amp;quot;$line&amp;quot; echo $((array[0] % array[1])) IFS=&amp;quot;\n&amp;quot; done &amp;lt; &amp;quot;$file&amp;quot; IFS=$IFS_OLD ls download/*.html | while read LINE; do perl parseDocs.pl $LINE 2&amp;gt;/dev/null done IFS=&#39;|&#39; read -a split_input &amp;lt;&amp;lt;&amp;lt; &amp;quot;$1&amp;quot; echo &amp;quot;Enter filename to parse: &amp;quot; read FILE [ -n $FILE ] || FILE=backend.conf # IFS=&amp;quot;$DELIM&amp;quot; while IFS=&#39;, \t&#39; read -r name port ssh_host ssh_port</description></item><item><title>Zsh中的别名</title><link>/linux/shell/zsh-alias/</link><pubDate>Thu, 26 Apr 2018 13:31:46 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/zsh-alias/</guid><description>路径别名 zsh 提供了一个很好用的功能，路径别名 这样针对很长的路径，就不用cd + Tab 来回切了 #define: hash -d dir_name=&amp;quot;dir_path&amp;quot; #usage: cd ~dir_name or ~dir_name hash -d myweb=&amp;quot;/data/www/mywebsite&amp;quot; cd ~myweb 或者 ~myweb 或者直接myweb 就相</description></item><item><title>Linux Bash-Zsh 快捷键模式 Emacs-Vim</title><link>/linux/shell/linux-zsh/</link><pubDate>Tue, 24 Apr 2018 14:36:45 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/linux-zsh/</guid><description>ZSH开发指南 zsh - Prompt Expansion 13 Prompt Expansion (zsh) 0=${(%):-%N} %N The name of the script If there is none, this is equivalent to the parameter $0 source ${0:A:h}/zsh.d/.zplug.zsh :A 等价于 readlink 读取原文件的地址 :h 字符串截取 目录 zsh compinit: insecure directories, run compaudit for list. Ignore insecure directories and continue [y]</description></item><item><title>bash中文手册Handbook</title><link>/linux/shell/handbook/</link><pubDate>Thu, 19 Apr 2018 14:40:33 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/handbook/</guid><description>前言 如果你是一个程序员，时间的价值想必心中有数。持续优化工作流是你最重要的工作之一。 在通往高效和高生产力的路上，我们经常不得不做一些重复的劳</description></item><item><title>Makefile 详解</title><link>/linux/shell/makefile/</link><pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/makefile/</guid><description>编译时混合使用动态库和静态库 编译某个测试代码时，出现了下面的错误： g++ -std=c++11 -o testlurkcli main.cpp -L. -llurkcli-lasl -static /usr/bin/ld: cannot find -lstdc++ /usr/bin/ld: cannot find -lm /usr/bin/ld: cannot find -lc collect2: error: ld returned 1 exit status 这个错误，是在最后的</description></item><item><title>Shell常用招式大全-入门篇</title><link>/linux/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</link><pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell%E5%B8%B8%E7%94%A8%E6%8B%9B%E5%BC%8F%E5%A4%A7%E5%85%A8%E5%85%A5%E9%97%A8%E7%AF%87/</guid><description>采用source 而不是bash 命令 可以将环境变量传递过去 第一招 HelloWorld 第一式：echo echo &amp;quot;Hello World&amp;quot; echo -n &amp;quot;Hello World&amp;quot; # 不带换行 echo -e &#39;\e[0;33;1mHello\e[0m World&#39; # 带颜色的玩法 echo -e &#39;\e[0;33;4mHello\e[0m World&#39; # 带颜</description></item><item><title>shell中冒号:的作用</title><link>/linux/shell/shell-%E5%86%92%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</link><pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-%E5%86%92%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</guid><description>I. 在shell 中冒号的作用 用作变量条件赋值 {str:=expr} 如果变量str不为空,${str:=expr}就等于str的值，若str为空，就把expr的值赋</description></item><item><title>shell中方括号在比较中的使用规则</title><link>/linux/shell/shell-%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</link><pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</guid><description>(括号)的作用 Shell中的括号有其特殊的用法, 现总结如下: 符号$后的括号 ${a} 变量a的值, 在不引起歧义的情况下可以省略大括号. $(cmd) 命令替换, 结果</description></item><item><title>shell中的map使用</title><link>/linux/shell/shell-array-map/</link><pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-array-map/</guid><description>bash 的版本必须 &amp;gt;= 4.1.2，升级bash： declare -A abc declare: usage: declare [-afFirtx] [-p] [name[=value] ...] shell中map的定义与使用 declare -A 变量名 #切记使用大写的A，不是小写的a [root@www ~]# declare -A</description></item><item><title>shell中的字符串截取</title><link>/linux/shell/shell-substr%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96/</link><pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-substr%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96/</guid><description>1、第一种方法: # ${varible##*string} 从左-&amp;gt;右截取最后一个string后的字符串 # ${varible#*string}从左-&amp;gt;右截取第一个str</description></item><item><title>shell基础</title><link>/linux/shell/shell%E5%9F%BA%E7%A1%80/</link><pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell%E5%9F%BA%E7%A1%80/</guid><description>sh &amp;quot;文件.sh&amp;quot; , 之后跟文件名,新开子进程执行 sh -c &amp;quot;命令&amp;quot; , 直接把要执行的命令传递给 sh -c &#39;let c=$PATH;echo &amp;quot;c=$c&amp;quot;&#39; &amp;qu</description></item><item><title>shell条件判断</title><link>/linux/shell/shell-compare%E6%AF%94%E8%BE%83/</link><pubDate>Tue, 07 Nov 2017 14:55:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-compare%E6%AF%94%E8%BE%83/</guid><description>value 数值比较 -eq 等于 if [ &amp;quot;$a&amp;quot; -eq &amp;quot;$b&amp;quot; ] -ne 不等于 if [ &amp;quot;$a&amp;quot; -ne &amp;quot;$b&amp;quot; ] -gt 大于 if [ &amp;quot;$a&amp;quot; -gt &amp;quot;$b&amp;quot; ] -ge 大于等于 if [ &amp;quot;$a&amp;quot; -ge &amp;quot;$b&amp;quot; ] -lt 小于 if [ &amp;quot;$a&amp;quot; -lt &amp;quot;$b&amp;quot; ] -le 小于等于 if [ &amp;quot;$a&amp;quot; -le &amp;quot;$b&amp;quot; ] &amp;lt; 小于（使用</description></item><item><title>Makefile自动变量</title><link>/linux/shell/makefile-variable/</link><pubDate>Sat, 09 Jan 2016 14:01:36 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/makefile-variable/</guid><description>.c.o : It&#39;s an old-fashioned suffix rule. The more up-to-date way to do it is to use a pattern rule: =&amp;gt; %.o : %.c 3.7 自动变量（Automatic Variables） Make命令还提供一些自动变量，它们的值与</description></item><item><title>Shell (双引号)与(单引号)的区别</title><link>/linux/shell/shell-%E5%BC%95%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</link><pubDate>Sat, 09 Jan 2016 14:01:36 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/shell-%E5%BC%95%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</guid><description>1. &amp;quot;&amp;quot;(双引号) 与&#39;&#39;(单引号) 差在哪？ hard quote：&#39;&#39;(单引号)，凡在 hard quote 中的所有 meta 均被关闭； soft quote：&amp;quo</description></item><item><title>Linux命令 bash</title><link>/linux/shell/bash/</link><pubDate>Wed, 06 Jan 2016 16:46:14 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/linux/shell/bash/</guid><description>Linux 技巧: Bash 测试和比较函数 Bash的=~正则表达式匹配 [](http://mywiki.wooledge.org/BashPitfalls/) 快捷键 编辑当前命令 把当前的命令行存放到文本编辑器中 &amp;lt;&amp;lt;&amp;lt; 就是将后面的内容作为前面命令的标准</description></item></channel></rss>